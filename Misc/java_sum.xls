CLASS	If you have the String representation of class name and list of Classes then you can just compare the String name with the simple name of each class. If a match is found then you can determine what class that object belongs to\n\nLets say you have\n\n\npublic static void main(String[] args){\n\nString objName = "Integer";\n\n// provided you have list of classes,\n\nfor(int i=0;i< classList.size(); i++){\n\tif(classList.get(i).class.getSimpleName().equals(objName)){\n\t\t // whatever you want to do\n\t}\n}\n}\n- grebuddies247 2 months ago | Flag Reply\n0\nof 0 vote\nYou can use Reflection. You can also use instanceof.					
PriorityQueue	PriorityQueue<Integer> queue = new PriorityQueue<>(10, Collections.reverseOrder());\nqueue.offer(1);\nqueue.offer(2);\nqueue.offer(3);\n//...\n\nInteger val = null;\nwhile( (val = queue.poll()) != null) {\n    System.out.println(val);\n}\nThe Collections.reverseOrder() provides a Comparator that would sort the elements in the PriorityQueue in a the oposite order to their natural order in this case.\n\nshareimprove this answer\nedited May 9 '14 at 1:23\nanswered Jun 12 '12 at 19:12\n\nEdwin Dalorzo\n30.5k569109\n  \t \t\nCollections.reverseOrder() is also overloaded to take a comparator, so it also works if you compare custom objects. Ð flying sheep Jul 4 '13 at 18:11\nadd a comment\n\nup vote\n4\ndown vote\nYou can provide a custom Comparator object that ranks in the reverse order:\n\nPriorityQueue<Integer> pq = new PriorityQueue<Integer>(defaultSize, new Comparator<Integer>() {\n    int compare(Integer lhs, Integer rhs) {\n        if (lhs > rhs) return +1;\n        if (lhs.equals(rhs)) return 0;\n        return -1					
array	oogle guava now provides a neat way to do this:\n\nList<Integer> list = ...;\nint[] values = Ints.toArray(list);  new int[]{1, 2, 3, 4, 5},, int[] arr = new int[list.size()];\nfor(int i = 0; i < list.size(); i++) {\n    arr[i] = list.get(i);\n}\n\n        System.out.println(Arrays.toString(nums));\n					
